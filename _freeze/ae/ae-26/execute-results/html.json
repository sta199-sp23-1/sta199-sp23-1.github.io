{
  "hash": "89ce9658215d5732f708906caff469ee",
  "result": {
    "markdown": "---\ntitle: \"Cryptanalysis\"\nsubtitle: \"STA 199\"\neditor: source\nformat: html\nexecute:\n  error: true\n---\n\n\n## Bulletin\n\n- this `ae` is **due for grade**. Push your completed ae to GitHub within 48 hours to receive credit\n- Project presentations and repo due Monday lab (by pushing to GitHub)\n- Extended deadline: project reports now due Wednesday\n- Don't forget about the statistics experience\n- course evaluations open. $>80\\%$ response $\\rightarrow$ +1pt final project\n\n## Getting started\n\nClone *your* `ae26-username` repo from the [GitHub organization](https://github.com/orgs/sta199-sp23-1/repositories).\n\n\n# Today\n\nBy the end of today, you will...\n\n- break a substitution cipher\n- understand the intuition behind an algorithm to do so, *Markov chain Monte Carlo* (MCMC)\n\n\n## Load packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(reshape2)\n```\n:::\n\n\nOur data includes\n\n1) Complete text of \"War and Peace\" by Leo Tolstoy\n2) Freq. analysis data frame of \"War and Peace\"\n3) A secret message\n\n## Background\n\nThis application exercise builds on the `R` code found [here](https://www.r-bloggers.com/2013/01/text-decryption-using-mcmc/) and [The Markov Chain Monte Carlo Revolution](https://math.uchicago.edu/~shmuel/Network-course-readings/MCMCRev.pdf) by Persi Diaconis.\n\n![](https://sta101.github.io/static/img/prisonLetter.png){width=75%}\n\nLet's load the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwarandpeace = readLines(\"https://sta101.github.io/static/appex/data/warandpeace.txt\")\nfrequency = read.table(\"https://sta101.github.io/static/appex/data/frequencies.txt\")\ncolnames(frequency) = c(toupper(letters), \"\") # edit column names\nsecret_message = readLines(\"https://sta101.github.io/static/appex/data/secret-message.txt\")\n```\n:::\n\n\n![](https://sta101.github.io/static/img/war-and-peace.jpg){width=25%}\n\n## Exercise 1\n\nTake a look at `secret-message`. Each letter is a stand in for exactly one other letter. This sort of cipher is known as a \"substitution cipher\".\n\n'A' could be encoded as one of 26 characters (A, B, C, ...). Once the encoding for 'A' is chosen, 'B' has 25 possibilities and so on so there are, in total $26 \\times 25 \\times 24 \\times \\ldots \\times 3 \\times 2 \\times 1$ possibilities.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn = 26\ninput = n + 1\nkeys = gamma(input)\nkeys\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.032915e+26\n```\n:::\n:::\n\nThat's over $4 \\times 10^{26}$ possible keys! If you could check 10M keys per second, it would take approximately $1 \\times 10^{12}$ (trillion) years to check every possible key. Trying every possible key is known as a \"brute force\" approach.\n\n- Chat with your neighbor and develop a strategy better than the brute force approach. Detail your strategy below.\n\n\n## Exercise 2 \n\nHere we determine how often one character follows another using the text from the very long book, War and Peace. We include a whitespace character as a 27th character in our alphabet.\n\nTo reduce computational demand, we will load the object created by this analysis but leave the code below for reference. \n\nThe result of the below analysis is in the object `frequency`.\n\nThe `letter` row denotes the first character in a 2 character sequence while columns determine the second character in the character sequence.\n\n- What should be the sum of a row? Check this for the first row of the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code here\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nCreate a [heatmap](https://ggplot2.tidyverse.org/reference/geom_bin_2d.html?q=heat#arguments) of character frequency, where the y-axis is the first letter and the x-axis is the second letter in a two letter chain. \n\n- Uncomment and complete the code below.\n\nHint: We'll use `melt` from the `reshape2` package. Click [here](http://www.sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization) for an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmelt_freq = melt(as.matrix(frequency))\n\n# melt_freq %>%\n#   ggplot(aes(x = __, y = __, fill = __))\n```\n:::\n\n\n## MCMC\n\nWe will use a famous statistical algorithm, Markov chain Monte Carlo (MCMC) to break the substitution cipher.\n\nMCMC is composed of three essential components:\n\n1. Ability. A way to propose any possible key.\n2. Feedback. A way to evaluate how good a given key is.\n3. Curiosity. A way to leave a good key for a worse key.\n\n#### The analogy of the blind monkey.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://sta101.github.io/static/img/monkey.png){fig-align='center' width=49% height=50%}\n:::\n\n::: {.cell-output-display}\n![](https://sta101.github.io/static/img/pond.png){fig-align='center' width=49% height=50%}\n:::\n:::\n\n\n\nThere's a monkey on an island with many ponds. The monkey has been tasked with finding the largest body of water on the island. The only trouble is, he is blind. In order to find the largest body of water, he throws rocks randomly and listens for a splash. If he hears a splash, he knows there's a body of water where he last threw. He continues to throw more rocks in that direction to find out how big the pool is. Occasionally he gets bored and wanders off to look for another pond. In this way, he uses the MCMC algorithm to find the largest body of water.\n\n#### Making the connection.\n\n1. Ability (throw a rock). The Monkey can walk around and throw the rock anywhere on the island, ensuring that given enough time, he will cover every inch of the island.\n\n2. Feedback (test for waters). Every time the Monkey throws the rock, he receives feedback by listening for a splash. A large splash means a deep pond and encourages him to continue throwing in that direction to figure out the perimeter of the pond.\n\n3. Curiosity (boredom). If the monkey finds the second largest pond on the island, he might get stuck throwing rocks in it for a long time. By occasionally walking away from a large pond, he will reach the largest pond quicker.\n\n\n## Exercise 3\n\nLet's write out together what MCMC looks like when decrpyting a secret message.\n\n1. Ability\n\n2. Feedback\n\n3. Curiosity\n\n## Exercise 4\n\nHere we load some functions that will help us decode the message.\n\n\n::: {.cell}\n\n:::\n\n\n\nRun the code below to break the secret message. If the message is unintelligible after several iterations, you may try re-starting with a new seed. What is this equivalent to in the monkey analogy above?\n\n\n::: {.cell}\n\n:::\n\n\n## Exercise 5\n\nTry your own message!\n\n\nCreate your own message in the code below and call `mcmcAttack(coded)` on your message to decode it!\n\n\n::: {.cell}\n\n:::\n\n\n- You might think about what makes the message easy or difficult to attack, e.g. does length of the message affect its susceptibility to attack? What else might?",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}